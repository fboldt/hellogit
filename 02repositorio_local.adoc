[#local]
== Iniciando um repositório local

Fisicamente no computador, um repositório Git é apenas um
diretório com algumas metainformações sobre as alterações 
dos arquivos do projeto que está no diretório.
A lista de comandos <<fig:01>>
mostra como criar um repositório Git do zero.
Note que foi criado um diretório oculto, por que começa com
um ponto (.), e por isso só é listado (`ls`) quando
se usa o parâmetro `-a`.

.Criando um repositório vazio.
[[fig:01, {counter:refcode}]]
[source]
----
~$ mkdir greetings // <1>
~$ cd greetings // <2>
~/greetings$ ls -a //<3>
. ..
~/greetings$ git init // <4>
Initialized empty Git repository in home/fulano/greetings/.git/
~/greetings$ ls -a // <5>
. .. .git
----
<1> Cria diretório greetings, onde colocaremos o código do nosso projeto.
<2> Acessa diretório greetings.
<3> Lista diretório incluindo arquivos ocultos.
<4> Cria um repositório a partir do diretório atual.
<5> Lista arquivos ocultos incluindo o diretório .git.


A árvore com todos os arquivos
e subdiretórios criado pelo comando `git init` pode ser
vista na lista de comandos <<fig:02>>. O comando `tree .git` foi
usado para exibir essa árvore. O diretório `.git` contém
metadados. Ou seja, é um diretório com dados para o Git
controlar os dados do repositórios. É a forma do Git
"lembrar" da história do projeto.
Um repositório Git nada mais é do que um diretório com um
subdiretório `.git` adequadamente estruturado.
O subdiretório `.git` não deve ser alterado diretamente.
Suas alterações devem ser feitas através do comando
`git` acompanhado dos parâmetros correspondentes à ação
desejada.

.Árvore de diretórios do repositório.
[[fig:02, {counter:refcode}]]
[source]
----
~/greetings$ tree .git
.git
├── branches
├── config
├── description
├── HEAD
├── hooks
│   ├── applypatch-msg.sample
│   ├── commit-msg.sample
│   ├── fsmonitor-watchman.sample
│   ├── post-update.sample
│   ├── pre-applypatch.sample
│   ├── pre-commit.sample
│   ├── pre-merge-commit.sample
│   ├── prepare-commit-msg.sample
│   ├── pre-push.sample
│   ├── pre-rebase.sample
│   ├── pre-receive.sample
│   └── update.sample
├── info
│   └── exclude
├── objects
│   ├── info
│   └── pack
└── refs
    ├── heads
    └── tags

9 directories, 16 files
----

=== O comando `git status`

Um comando que é usado o tempo todo em um repositório Git é o 
comando `git status` apresentado na lista de comandos <<fig:03>>.
Apesar desse comando estar em uma seção dedicada a ele, 
devido a sua importância, ele não será abordado em profundidade,
uma vez que nosso objetivo aqui é mostrar uma utilização do Git
com poucos comandos, sem explorá-los por completo.

.Árvore de diretórios do repositório.
[[fig:03, {counter:refcode}]]
[source]
----
~/greetings$ git status
On branch master // <1>

No commits yet // <2>

nothing to commit (create/copy files and use "git add" to track) // <3>
----

<1> A resposta desta linha é `On branch master`.
_Banches_ são ramificações de um projeto Git, 
que podem tomar rumos diferentes durante seu desenvolvimento.
Diferentes ramos podem ser mesclados ou se tornarem novos 
projetos. O nome `master` é o nome padrão para o ramo inicial 
do projeto Git.
Não existe nenhuma exigência de que esse ramo exista.
É que raramente se muda esse nome.

<2> Esta linha mostra `No commits yet`.
Os _commits_ são fotografias do sistema que o Git mantém
em seus metadados no diretório `.git`.
Como não fizemos nenhum _commit_ ainda, não existe nenhuma
"fotografia" no Git.

<3> Aqui aparece
`nothing to commit (creat/copy files and use "git add" to track)`.
Não há nada para "fotografar" (_commit_) por que o diretório
do projeto está vazio.
Nenhum arquivo está sendo monitorado.
Para monitorar um arquivo temos que usar o comando `git add`,
que é apresentado na pŕoxima seção.

=== Criando um arquivo novo

Como pode ser traduzido da terceira linha de resposta da lista de comandos
<<fig:03>>, o Git monitora (_track_) arquivos criados
ou copiados para dentro do diretório do repositório.
A lista de comandos <<fig:04>> mostra o conteúdo que queremos no arquivo
`greet.py`. Este arquivo em texto simples pode ser criado 
dentro do diretório ou copiado para dentro dele.
É um arquivo escrito em linguagem de programação Python 3.
Porém, não é necessário saber Python para acompanhar este 
tutorial. Basta notar que o arquivo será alterado e cada 
alteração será monitorada pelo Git.

.Criando o primeiro arquivo do projeto
[[fig:04, {counter:refcode}]]
[source]
----
~/greetings$ cat greet.py / <1>
print("hello")
~/greetings$ python greet.py // <2>
hello
~/greetings$ ls -a // <3>
.  ..  .git  greet.py
----
<1> Mostra o conteúdo do arquivo `greet.py`.
<2> (Opcional) Executa o arquivo criado com o comando `python 
greed.py`. 
<3> Só para mostrar que o arquivo `greed.py` foi criado.

Depois de criado o arquivo `greet.py`, o comando
`git status` mostrará uma resposta um pouco diferente,
como mostra a lista de comandos <<fig:05>>.

.Status com arquivo fora da área de stage
[[fig:05, {counter:refcode}]]
[source]
----
~/greetings$ git status
On branch master // <1>

No commits yet // <2>

Untracked files: // <3>
  (use "git add <file>..." to include in what will be committed)
	greet.py

nothing added to commit but untracked files present (use "git add" to track) // <4>
----

<1> A primeira 
<2> e a segunda linha de resposta continuam iguais,
<3> mas a terceira linha de resposta lista o arquivo
`greet.py` em vermelho, e diz que ele não está
sendo monitorado (_untracked_).
<4> Veja que a resposta do comando já diz como adicionar
a modificação no monitoramento (`git add <file>`).

Aqui é um ponto que merece uma atenção especial quando se usa o Git.
O Git só "fotografa" (_commit_) as alterações que estão
em uma área abstrata de sua organização chamada *_stage_*.
Isso por que, muitas vezes fazemos alterações que não queremos 
gravar. Testamos algo, não gostamos do resultado, e queremos 
descartar o que foi feito. Outras vezes, queremos gravar só 
algumas alterações, mas não todas. 
Esse processo também nos permite fazer alterações variadas e 
agrupá-las em fotografias separadas.


A lista de comandos <<fig:06>> mostra como adicionar um arquivo na área de 
_stage` do Git, com o comando `git add greet.py`.
Note que agora o arquivo está sendo monitorado, mas ainda não 
foi "fotografado" (_committed_).
Se você colocar um arquivo na área de _stage_ por engano,
pode removê-lo de lá, sem excluí-lo do diretório, com o 
comando `git rm --cached <file>`, como mostra a resposta 
do comando `git status`.

.Status com arquivo na da área de stage
[[fig:06, {counter:refcode}]]
[source]
----
~/greetings$ git add greet.py 
~/greetings$ git status
On branch master

No commits yet

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
	new file:   greet.py

----

=== Monitorando o arquivo criado

É importante resaltar que até o momento, nenhum arquivo está
sendo monitorado pelo Git.
O arquivo `greet.py` está pronto para ser "fotografado" e,
a partir daí, ser monitorado.
Para fotografar as mudanças que estão na área de *_stage_*
deve-se executar o comando da lista de comandos <<fig:07>>.
Entretanto, o comando só será aceito se você estiver com 
seu nome e email configurado.
Para não entrar em detalhes de configuração agora, 
você pode digitar os comandos 
`git config user.name `SEU_PRIMEIRO_NOME SEU_ULTIMO_NOME'` e
`git config user.email `SEU_EMAIL@example.com'`.
Quando se executa o comando `git commit` sem o parâmetro
`-m 'comentário'` o Git abre um editor de texto para que 
um comentário sobre a fotografia seja escrito.
O Git não permite commits sem comentários.
Então, foi usado aqui o `-m` para ficar mais resumido e 
visível através das listas de comandos.

.Primeira fotografia do repositório
[[fig:07, {counter:refcode}]]
[source]
----
~/greetings$ git commit -m 'primeira fotografia do sistema'
[master (root-commit) 06cbe0b] primeira fotografia do sistema
 1 file changed, 1 insertion(+)
 create mode 100644 greet.py
----

Se você quiser ver a fotografia tirada do sistema
pode usar o comando `git show` e terá um resultado
parecido com o da lista de comandos <<fig:08>>.
Vamos entender essa fotografia, mas sem seguir a ordem em que 
os dados aparecem.

.Vendo detalhes da fotografia mais recente do sistema
[[fig:08, {counter:refcode}]]
[source]
----
~/greetings$ git show // <1>
commit 06cbe0b360ee871baf55d48aa1914d8b73708b4b (HEAD -> master) //<2>
Author: Francisco de Assis Boldt <fboldt@gmail.com> //<3>
Date:   Tue Dec 22 08:21:39 2020 -0300 //<4>

    primeira fotografia do sistema //<5>

diff --git a/greet.py b/greet.py
new file mode 100644
index 0000000..11b15b1
--- /dev/null //<6>
+++ b/greet.py //<7>
@@ -0,0 +1 @@
+print("hello") //<8>
----
<1> O comando `git show`.
<2> Logo depois da palavra commit, está o _hash_ da fotografia.
O _hash_ é a assinatura, o identificador, da fotografia.
Podemos usar esse identificador para acessar a fotografia
posteriormente. Na mesma linha temos a palavra *master*,
indicando que o ramo do projeto chamado *master* está
apontando para esta fotografia no momento.
Ainda na mesma linha, em azul, temos a palavra *HEAD* 
seguida uma seta (\->).
Esta seta indica que o estado do sistema que estamos vendo no
momento está apontando para o ramos master.
Isso ficará mais claro a seguir.
<3> Quem fez a fotografia
(dados inseridos pelos comandos `git config <etc>`).
<4> Quando a fotografia foi feita.
<5> O comentário inserido pelo comando `git commit`.

=== Conclusão

Com o que foi mostrado neste capítulo, já dá para usar o Git
para desenvolver seus programas.
Nossos programas e outros documentos raramente são criados
de uma vez. Começamos com uma versão simples e vamos 
incrementando versão após versão até finalizarmos o que
precisamos fazer.
Então, agora, ao invés de fazer uma cópia dos nossos arquivos,
podemos simplesmente alterar o arquivo sem medo.
