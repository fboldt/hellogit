[#fotografias]
== Criando fotografias novas e acessando fotografias antigas

O Git só vai tirar uma nova fotografia do sistema se algo for 
alterado e colocado na área de stage.
A figura <<fig:09>> mostra a alteração sugerida.
O resultado do programa continuou quase igual, por isso
a palavra "hello" foi colocada toda em maiúsculo 
para ficar mais clara que uma alteração foi feita.

.Fazendo uma alteração
[[fig:09, {counter:refcde}]]
[source]
----
~/greetings$ cat greet.py 
def main():
    print("Hello!")

main()
----

Depois da alteração do arquivo, o comando `git status
apresenta um retorno diferente, como mostra a figura 
<<fig:10>>.
Novamente o arquivo `greet.py` está em vermelho
por não estar na área de stage,
mas agora esse arquivo está sendo monitorado. 
Então temos duas opções.
Podemos descartar as alterações com o comando 
`git restore greet.py` ou podemos adicionar 
as alterações na área de stage com o comando
`git add greet.py`.
Adicionaremos as alterações na área de stage, como mostra a
figura <<fig:11>>.

.Status com arquivo modificado fora da area de stage
[[fig:10, {counter:refcde}]]
[source]
----
~/greetings$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   greet.py

no changes added to commit (use "git add" and/or "git commit -a")
----


.Status com arquivo modificado na da area de stage
[[fig:11, {counter:refcde}]]
[source]
----
francisco@i7titanv:~/greetings$ git add greet.py 
francisco@i7titanv:~/greetings$ git status
On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   greet.py
----

O resultado do comando `git status` está muito parecido 
com o da figura <<fig:06>>. Agora, em verde, não aparece
mais "arquivo novo" (new file), mas "modificado" (modified).

A figura <<fig:12>> mostra o comando `git commit` com o
parâmetro `-m` e um comentário relacionado à alteração feita.
O comando `git show` mostra como ficou a fotografia.
A linha em vermelho que inicia com o sinal $-$ mostra
o que foi removido, e as linhas em verde que iniciam com
o sinal $+$ mostram o que foi adicionado.

.Atualizando o repositório e vendo os detalhes da atualização
[[fig:12, {counter:refcde}]]
[source]
----
~/greetings$ git commit -m 'cria função main'
[main e0fe2b3] cria função main
 1 file changed, 4 insertions(+), 1 deletion(-)
----

[[fig:12a, {counter:refcde}]]
[source]
----
~/greetings$ git show
commit e0fe2b32abaa5b4bcb7a1889a820f155e9ec635e (HEAD -> main)
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 08:24:50 2020 -0300

    cria função main

diff --git a/greet.py b/greet.py
index 693eaec..55bb9ae 100644
--- a/greet.py
+++ b/greet.py
@@ -1 +1,4 @@
-print("Hello!")
+def main():
+    print("Hello!")
+
+main()
----

Vamos fazer mais uma alteração no sistema, que pode ser
vista na figura <<fig:13>>.
Novamente, o resultado do programa é virtualmente o mesmo,
e para que a alteração seja um pouco mais evidente, 
a palavra _Hello_ foi colocada agora apenas com
a primeira letra em maiúsculo.

.Fazendo mais uma alteração
[[fig:13, {counter:refcde}]]
[source]
----
~/greetings$ cat greet.py 
def main():
    print("Hello!")

if __name__ == "__main__":
    main()
----

Depois dessa alteração, o comando `git status`
apresentará o mesmo retorno visto na figura <<fig:10>>.
Vamos adicionar à área de stage a nova alteração com
o comando `git add greet.py`.
Após executado esse comando, o status do repositório
será igual ao apresentado na figura <<fig:11>>.

Agora estamos prontos para executar o comando `commit` 
como mostra a figura <<fig:14>>.
Novamente podem ser vistas as alterações feitas observando-se
as linhas verdes e vermelhas.

.git status
[[fig:14-a, {counter::refcde}]]
[source]
----
~/greetings$ git status 
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   greet.py

no changes added to commit (use "git add" and/or "git commit -a")
----

.git add
[[fig:14-b, {counter:refcde}]]
[source]
----
francisco@i7titanv:~/greetings$ git add greet.py 
francisco@i7titanv:~/greetings$ git status 
On branch main
Your branch is ahead of 'origin/main' by 1 commit.
  (use "git push" to publish your local commits)

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
	modified:   greet.py
----

.Atualizando com a terceira alteração
[[fig:14, {counter:refcde}]]
[source]
----
~/greetings$ git commit -m 'verifica se é o programa principal'
[main bd61894] verifica se é o programa principal
 1 file changed, 2 insertions(+), 1 deletion(-)
----

.git show
[[fig:14a, {counter:refcde}]]
[source]
----
~/greetings$ git show
commit bd618942ddf84ad2ceb062b7ef53c22b12a94dae (HEAD -> main)
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 08:55:49 2020 -0300

    verifica se é o programa principal

diff --git a/greet.py b/greet.py
index 55bb9ae..3062fd5 100644
--- a/greet.py
+++ b/greet.py
@@ -1,4 +1,5 @@
 def main():
     print("Hello!")
 
-main()
+if __name__ == "__main__":
+    main()
----

Agora temos cópias seguras das versões anteriores
do nosso projeto. 


=== Listando as fotografias do repositório

A figura <<fig:15>> mostra como listar as fotografias do 
sistema com o comando `git log`.
A opção `--oneline` foi usada aqui para que 
as fotografias sejam vistas de um forma mais compacta.
Mas vocë deve testar sem essa opção também.

.Listando as fotografias do repositório
[[fig:15, {counter:refcde}]]
[source]
----
~/greetings$ git log --oneline
bd61894 (HEAD -> main) verifica se é o programa principal
e0fe2b3 cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

As fotografias do repositório são apresentadas em ordem cronológica
reversa. Ou seja, a última fotografia é a primeira a ser apresentada
e a primeira fotografia é a última.
Em amarelo vemos o hash de cada fotografia.
Normalmente, essa parte do hash é suficiente para acessar a
fotografia.
Por exemplo, é possível ver uma fotografia mais antiga 
(ou mais recente) com o comando `git show <hash>`,
onde normalmente a parte do hash que aparece na figura
<<fig:15>> é suficiente para identificá-la.


=== Mostrando o conteúdo de fotografias

Na figura <<fig:16>> o comando `git show
mostra a fotografia anterior usando apenas a parte de seu hash
listada na figura <<fig:15>>.

.Vendo detalhes da fotografia anterior
[[fig:16, {counter:refcde}]]
[source]
----
~/greetings$ git show e0fe2b3
commit e0fe2b32abaa5b4bcb7a1889a820f155e9ec635e
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 08:24:50 2020 -0300

    cria função main

diff --git a/greet.py b/greet.py
index 693eaec..55bb9ae 100644
--- a/greet.py
+++ b/greet.py
@@ -1 +1,4 @@
-print("Hello!")
+def main():
+    print("Hello!")
+
+main()
----

A figura <<fig:17>> mostra a primeira fotografia do repositório.

.Vendo detalhes da fotografia da primeira fotografia
[[fig:17, {counter:reffg}]]
[source]
----
~/greetings$ git show 6c8951a
commit 6c8951a5c2979932ffaed078139616584afd8543
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Tue Dec 22 08:41:06 2020 -0300

    cria arquivo greet.py

diff --git a/greet.py b/greet.py
new file mode 100644
index 0000000..693eaec
--- /dev/null
+++ b/greet.py
@@ -0,0 +1 @@
+print("Hello!")
----

=== Alterando o estado do sistema

O comando `git checkout` permite colocar o repositório
em um estado gravado em alguma fotografia. 
A figura <<fig:18>> mostra como fazer o repositório
voltar para o estado em que a função `main
foi criada.

.Voltando o sistema para o estado da fotografia anterior
[[fig:18, {counter:refcde}]]
[source]
----
~/greetings$ git checkout e0fe2b3
Note: switching to 'e0fe2b3'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at e0fe2b3 cria função main
----

Veja na figura <<fig:20>> que o programa `greet.py
voltou ao seu estado anterior.

.Estados dos arquivos do sistema depois de voltar uma fotografia
[[fig:20, {counter:refcde}]]
[source]
----
~/greetings$ cat greet.py 
def main():
    print("Hello!")

main()
----

Ao listar as fotografias do repositório, como mostra a figura 
<<fig:19>>, o comando `git log` não mostra mais o brach master, nem a fotografia da última alteração feita.
Além disso, *HEAD* agora está na fotografia da segunda 
alteração.

.Listando fotografias tão ou mais antigas que a atual
[[fig:19, {counter:refcde}]]
[source]
----
~/greetings$ git log --oneline
e0fe2b3 (HEAD) cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

Você pode estar se perguntando "Git é então um complexo ctrl+z?". Claro que não!
A fotografia mais recente continua sendo monitorada e 
pode ser visualizada com a opção `--all
no comando `git log`, como mostra a 
figura <<fig:21>>.

.Listando todas fotografias do repositório
[[fig:21, {counter:refcde}]]
[source]
----
~/greetings$ git log --oneline --all
bd61894 (main) verifica se é o programa principal
e0fe2b3 (HEAD) cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

Na verdade, o Git sempre adiciona informação ao repositório.
Mesmo sendo possível remover informações de um repositório,
isso é raramente recomendado.

A figura <<fig:22>> mostra como colocar o sistema no
estado da fotografia mais recente.

.Voltando para versão mais recente do sistema
[[fig:22, {counter:refcde}]]
[source]
----
~/greetings$ git checkout main
Previous HEAD position was e0fe2b3 cria função main
Switched to branch 'main'
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)
----

=== Criando etiquetas para fotografias

Para facilitar o acesso das fotografias pode-se etiquetá-las.
O tipo de etiqueta mais comum é mostrado na figura
<<fig:23>>, que usa o comando `git tag` com a
opção `-a`. Esta opção permite usar a opção 
`-m` para inserir um comentário na etiqueta.

.Criando etiquetas para a fotografia atual
[[fig:23, {counter:refcde}]]
[source]
----
~/greetings$ git tag -a v0.3 -m 'Versão bem complexa para um programa Hello World'
~/greetings$ git log --oneline --all
bd61894 (HEAD -> main, tag: v0.3) verifica se é o programa principal
e0fe2b3 cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

O comando `git tag` coloca a etiqueta na fotografia atual
do sistema, mas é possível etiquetar outras fotografias 
através de seu hash, como mostra a figura <<fig:25>>.

.Etiquetando uma fotografia mais antiga
[[fig:25, {counter:refcde}]]
[source]
----
~/greetings$ git tag -a v0.3 -m 'Versão bem complexa para um programa Hello World'
----

.log
[[fig:25a, {counter:refcde}]]
[source]
----
~/greetings$ git log --oneline --all
bd61894 (HEAD -> main, tag: v0.3) verifica se é o programa principal
e0fe2b3 cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

A figura <<fig:26>> mostra coma acessar uma fotografia antiga 
através de sua etiqueta

.Acessando uma fotografia antiga através da sua etiqueta
[[fig:26, {counter:reffg}]]
[source]
----
~/greetings$ git checkout v0.2
Note: switching to 'v0.2'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at e0fe2b3 cria função main
----

.git log
[[fig:26a, {counter:refcde}]]
[source]
----
~/greetings$ git log --oneline --all
bd61894 (tag: v0.3, main) verifica se é o programa principal
e0fe2b3 (HEAD, tag: v0.2) cria função main
933fc74 (origin/main, origin/HEAD) Update README.md
6c8951a cria arquivo greet.py
58da81b Initial commit
----

O comando `git tag` pode ser usado para listar as
etiqueta, como mostra a figura <<fig:28>>.


.Listando todas as etiquetas do repositório
[[fig:28, {counter:refcde}]]
[source]
----
~/greetings$ git tag
v0.2
v0.3
----

Listagens mais complexas, com caracteres coringa por exemplo, 
podem ser feitas com esse comando, mas não serão exploradas aqui.

Quando se executa o comando `git show` com uma etiqueta,
ele mostra também os dados da etiqueta, como pode ser visto na
figura <<fig:24>>.
A informação de quem fez a etiqueta (tagger) e de quando 
a etiqueta foi criada só é gravada se a opção `-a
for usada na criação dela.

.Mostrando fotografias usando etiquetas
[[fig:24, {counter:refcde}]]
[source]
----
~/greetings$ git show v0.2
commit e0fe2b32abaa5b4bcb7a1889a820f155e9ec635e (tag: v0.2)
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 08:24:50 2020 -0300

    cria função main

diff --git a/greet.py b/greet.py
index 693eaec..55bb9ae 100644
--- a/greet.py
+++ b/greet.py
@@ -1 +1,4 @@
-print("Hello!")
+def main():
+    print("Hello!")
+
+main()
----

.Mostrando fotografias usando etiquetas
[[fig:24a, {counter:refcde}]]
[source]
----
~/greetings$ git show v0.3
tag v0.3
Tagger: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 09:11:24 2020 -0300

Versão bem complexa para um programa Hello World

commit bd618942ddf84ad2ceb062b7ef53c22b12a94dae (HEAD -> main, tag: v0.3)
Author: Francisco de Assis Boldt <fboldt@gmail.com>
Date:   Wed Dec 23 08:55:49 2020 -0300

    verifica se é o programa principal

diff --git a/greet.py b/greet.py
index 55bb9ae..3062fd5 100644
--- a/greet.py
+++ b/greet.py
@@ -1,4 +1,5 @@
 def main():
     print("Hello!")
 
-main()
+if __name__ == "__main__":
+    main()
----


É importante notar que *HEAD* não aponta para nenhum
branch. No caso, não aponta para *main*, que é 
o único branch do repositório.
Para continuar o tutorial execute o comando da
figura <<fig:29>>, para que *HEAD* aponte para 
*master*.


.git checkout main
[[fig:27, {counter:refcde}]]
[source]
----
~/greetings$ git checkout main
Switched to branch 'main'
Your branch is ahead of 'origin/main' by 2 commits.
  (use "git push" to publish your local commits)
----
